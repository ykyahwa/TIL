# 애노테이션과 리플렉션

```
1. 애노테이션 적용과 정의
2. 리플렉션을 사용해 실행 시점에 객체 내부 관찰
3. 코틀린 실전 프로젝트 예제
```

* 애노테이션을 사용하면 라이브러리가 요구하는 의미를 클레스에 부여 할 수 있다
* 애노테이션 직접 만들기 어렵고, 처리하는 코드 작성하기는 더 어렵다
* 애노테이션 사용은 자바와 동일, 선언 하는 문법이 약간 다르다.
* 리플렉션을 사용하면 실행 시점에 컴팡일러 내부 구조를 분석할 수 있다.
* 리플렉션 API의 일반 구조는 자바와 같지만 세부 사항에서 약간 차이가 있다.

## 10.1 애노테이션 선언과 적용

### 10.1.1 애노테이션 적용
> 애노테이션은 @ 과 이름 으로 이뤄진다.

```kotlin
class Test {
    // @TEST 애노테이션으로 제이유닛 프레임워크에 메서드를 호출하라고 지시
    @Test fun test() {
        Assert.assertTrue(true)
    }
}
```


@Deprecated 
 - 자바와 동일. 
 - replaceWith 파라미터 제공 
 -  인텔리J 에서 경고 메시지와 퀵픽스 제시
```kotlin
@deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) {...}
```
> 애노테이션 인자를 넘길 때는 괄호 안에 인자를 넣는다. 

> 애노테이션 인자로 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션클래스, 배열(앞에 요소) 
 - 클래스를 애노테이션 인자로 지정할 때는 ::class를 넣어야 한다. ex) @MyAnnotation(MyClass::class)
 - 다른 애노테이션을 인저로 넣을 때는 @를 넣지 않아야 한다. ReplaceWith는 애노테이션 이다.
 - 배열을 지정할려면 arrayOf 함수를 사용한다. ex) @RequestMapping(path = arrayOf("/foo","/var"))
 - 자바에서 선언한 애노테이션 클래스를 사용한다면 value 라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환 된다. @JavaAnnotaionWithArrayValue("acb", "foo", "bar") 처럼 arrrayOf 함수를 쓰지 않아도 된다.
 - 프로퍼티는 인자로 사용하려면 const를 붙여야 한다. 
 

 ### 10.1.2 애노테이션 대상
 > 코틀린 소스코드에서 한 선언을 컴파일한 결과가 여러 자바선언과 대응하는 경우가 자주 있다. 코틀린 선언에 대응하는 자바 선언에 각각 애노테이션을 붙여야 할 때가 있다. ex) 코틀린 프로퍼티는 자바 필드와 게터 메서드 선언과 대응한다.

 사용지점대상(use-site target) 선언으로 애노테이션을 붙일 요소를 정할 수 있다.
 
 @사용지점대상:애노테이션이름 

 @get:Rule

