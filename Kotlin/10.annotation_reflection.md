# 애노테이션과 리플렉션

```
1. 애노테이션 적용과 정의
2. 리플렉션을 사용해 실행 시점에 객체 내부 관찰
3. 코틀린 실전 프로젝트 예제
```

* 애노테이션을 사용하면 라이브러리가 요구하는 의미를 클레스에 부여 할 수 있다
* 애노테이션 직접 만들기 어렵고, 처리하는 코드 작성하기는 더 어렵다
* 애노테이션 사용은 자바와 동일, 선언 하는 문법이 약간 다르다.
* 리플렉션을 사용하면 실행 시점에 컴팡일러 내부 구조를 분석할 수 있다.
* 리플렉션 API의 일반 구조는 자바와 같지만 세부 사항에서 약간 차이가 있다.

## 10.1 애노테이션 선언과 적용

### 10.1.1 애노테이션 적용
> 애노테이션은 @ 과 이름 으로 이뤄진다.

```kotlin
class Test {
    // @TEST 애노테이션으로 제이유닛 프레임워크에 메서드를 호출하라고 지시
    @Test fun test() {
        Assert.assertTrue(true)
    }
}
```


@Deprecated 
 * 자바와 동일. 
 * replaceWith 파라미터 제공 
 *  인텔리J 에서 경고 메시지와 퀵픽스 제시

```kotlin
@deprecated("Use removeAt(index) instead.", ReplaceWith("removeAt(index)"))
fun remove(index: Int) {...}
```

> 애노테이션 인자를 넘길 때는 괄호 안에 인자를 넣는다. 

> 애노테이션 인자로 원시 타입의 값, 문자열, enum, 클래스 참조, 다른 애노테이션클래스, 배열(앞에 요소) 
 * 클래스를 애노테이션 인자로 지정할 때는 ::class를 넣어야 한다. ex) @MyAnnotation(MyClass::class)
 * 다른 애노테이션을 인저로 넣을 때는 @를 넣지 않아야 한다. ReplaceWith는 애노테이션 이다.
 * 배열을 지정할려면 arrayOf 함수를 사용한다. ex) @RequestMapping(path = arrayOf("/foo","/var"))
 * 자바에서 선언한 애노테이션 클래스를 사용한다면 value 라는 이름의 파라미터가 필요에 따라 자동으로 가변 길이 인자로 변환 된다. @JavaAnnotaionWithArrayValue("acb", "foo", "bar") 처럼 arrrayOf 함수를 쓰지 않아도 된다.
 * 프로퍼티는 인자로 사용하려면 const를 붙여야 한다. 
 

 ### 10.1.2 애노테이션 대상
 > 코틀린 소스코드에서 한 선언을 컴파일한 결과가 여러 자바선언과 대응하는 경우가 자주 있다. 코틀린 선언에 대응하는 자바 선언에 각각 애노테이션을 붙여야 할 때가 있다. ex) 코틀린 프로퍼티는 자바 필드와 게터 메서드 선언과 대응한다.

 사용지점대상(use-site target) 선언으로 애노테이션을 붙일 요소를 정할 수 있다.
 
 @사용지점대상:애노테이션이름 

 @get:Rule

규칙을 지정하려면 공개(public) 필드, 메스드 앞에 @Rule 붙여야 한다.

```kotlin
class HasTempFolder {
    @get:Rule //프로퍼티가 아닌 게터에 애노테이션을 붙인다.
    val folder = TemporaryFolder()

    @Test
    fun testUsingTempFolder() {...}
}
```

* property - 프로퍼티 전체, 자바에서 선언된 애노이테션에서는 사용 불가
* field - 프로퍼티에 의해 생성되는 필드
* get
* set
* receiver - 확장 함수, 프로퍼티 수신 객체 파라미터
* param - 생성자 파라미터
* setparam - 새터 파라미터
* delegate - 위임 프로퍼티의 위임 인스턴스를 담아둔 필드
* file - 파일 안에 선언된 최상위 함수와 프로퍼티를 담아두는 클래스, package 선언 앞에서 적용 할 수 있다. ex) @file:JvmName("StringFunctions")

```
자바 API를 애노테이션으로 제어하기
@Volatile, @Strictfp
@JvmName - 자바 필드나 메서드 이름을 변경
@JvmStatic - 자바 정적 메서드
@JvmOverloads - 오버로딩 함수 생성
@JvmField - 게터 세터가 없는 public 자바 필드로 프로퍼티 노출
```

### 10.1.3 애노테이션을 활용한 JSON 직렬화 제어

직렬화 - 객체를 저장하거나 네트워크로 전송하기 위해 텍스트나 이진 형식으로 변환 한다

역직렬화 - 텍스트나 이진 형식으로 저장된 데이터를 원래의 객체를 만들어 낸다.

JSON 라이브러리 - Jackson, GSON, jkid

```kotlin
data class Pserson(val name: String, val age: Int)

val person = Person("Alice", 29)
println(serialize(person))

{"age":29, "name": "Alice"}
```

```kotlin
val json = """{"name": "Alice", "age": 29}"""
println(deserialize<Person>(json)) //타입 인자 클래스를 명시해야한다.

Person(name=Alice, age=29)
```

* @JsonExclude - 직렬화, 역직렬화시 프로퍼티 무시
* @JsonName - 프로퍼티 이름 대신 애노테이션 이름을 쓴다.

```kotlin
data class Person(
    @JsonName("alias") val firstName: String, 
    @JsonExclude val age: Int? = null) //디폴트 값을 지정해야한다. 디폴트 값이 없으면 역직렬화 할수 없다.
```

### 10.1.4 애노테이션 선언

```kotlin
annotation class JsonExclude
```

* 애노테이션클래스는 선언이나 식과 관련 있는 메타데이터의 구조만 정의 할 수 있다. 내부에 아무 코드도 들어있을 수 없다.

```kotlin
annotation class JsonName(val name: String) // 파라미터에 val을 붙여야 한다.

@JsonName(name = "Lee")
@JsonName("Lee")

//자바
public @interface JsonName {
    String value(); //특별??
}
```

### 10.1.5 메타애노테이션: 애노테이션을 처리하는 방법 제어

> 메타애노테이션 - 애노테이션 클래스에 적용할 수 있는 애노테이션

```kotlin
// 표준 라이브러리 메타애노테이션. 적용가능 대상 지정
// @Target(AnnotationTarget.CLASS, AnnotationTarget.METHOD)
@Target(AnnotationTarget.PROPERTY) 
annotation class JsonExclude
```

```kotlin
@Target(AnnotationTarget.ANNOTATION_CLASS) //메타애노테이션을 직접 만들때 사용
annotation calss BindingAnnotation

@BindingAnnotation
annotation class MyBinding
```
 PROPERTY로 지정한 애노테이션은 자바에서 사용 할 수 없다. FIELD를 추가 해야한다.



@Retention 애노테이션 
 - 애노테이션클래스를 소스 수준, .class 파일에 저장, 실행 시점에 리플렉션을 사용 가능 여부를 지정하는 메타애노테이션
 - 자바는 기본 .class는 저장하지만 런타임에는 사용할수 없게 한다.
 - 코틀린에서는 기본 @Retention을 RUNTIME으로 지정

### 10.1.6 애노테이션 파라미터로 클래스 사용

@DeserializeInterface 인터페이스 타입인 프로퍼티에 대한 역직렬화를 제어할 때 쓰는 애노테이션

```kotlin
interface Company {
    val name: String
}
data class CompanyImple(override val name: String) : Company

//Person 역직렬화 시 company에 CompanyImple 인스턴스를 만들어 설정한다.
data class Person(
    val name: String,
    @DeserializeInterface(CompanyImpl::class) val company: Company
)
```

```kotlin
annotation class DeserializeInterface(val targetClass: KClass<out Any>)
//공병성.....KClass<CompanyImpl> 은 KClass<out Any>의 하위 타입이다.
```

### 10.1.7 애노테이션 파라미터로 제네릭 클래스 받기

> 제이키드는 원시 타입이 아닌 프로퍼티를 중첩된 객체롤 직렬화한다.

@CustomSerializer 커스텀 직렬화 클래스에 대한 참조를 인자로 받는다. 커스텀 직렬화 클래스는 ValueSerializer 인터페이스를 구현해야한다.

```kotlin
interface ValueSerializer<T> {
    fun toJsonValue(value: T) : Any?
    fun fromJsonValue(jsonValue: Any?): T
}
```

```kotlin
object DateSerializer : ValueSerializer<Date> {
    private val dateFormat = SimpleDateFormat("dd-mm-yyyy")

    override fun toJsonValue(value: Date): Any? =
            dateFormat.format(value)

    override fun fromJsonValue(jsonValue: Any?): Date =
            dateFormat.parse(jsonValue as String)
}

data class Person(
    val name: String,
    @CustomSerializer(DateSerializer::class) val birthDate: Date
)
```

```kotlin
annotation class CustomSerializer(
    //어떤 타입이 올지 알수 없으므로 스타프로젝션을 사용
    val serializerClass: KClass<out ValueSerializer<*>>
)
```

* 클래스 인자 - KClass<out 허용할 클래스 이름>
* 제너릭 클래스 인자 - KClass<out 허용할 클래스 이름<*>>

## 10.2 리플렉션: 실행 시점에 코틀린 객체 내부 관찰