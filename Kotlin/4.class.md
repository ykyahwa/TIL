# Class

## 인터페이스
 
 * 추상메서드와 구현이 있는 메서드도 가능하다.
 * 상태필드는 들어갈수 없다
 * override 변경자를 꼭 써야한다.

```kotlin
interface Parent {
    fun aa()
}

class Child: Parent {
    override fun aa() = println("aa")
}
```

 > 인터페이스에 본문이 있는 메서드
```kotlin
interface ParentA {
    fun aa()
    fun bb() = println("ParentA bb")
}

interface ParentB {
    fun ab() = println("ParentB ab")
    fun bb() = println("ParentB bb")
}

class Child : ParentA, ParentB {
    override fun aa() = println("Child aa")
    
    //공통된 추상메서드가 있을경우 반드시 override 해주어야 한다.
    override fun bb() {
        //super<상위타입> 으로 지정하여 호출하여 명시해준다.
        super<ParentA>.bb()
        super<ParentB>.bb()
    }
}
```

## open, final, abstract
 * 클래스와 메서드가 상속에 대해서 기본적으로 final이다.
 * 상속하고 싶은 클래스, 메서드, 프로퍼티 앞에 open을 붙여서 상속을 허용해야한다.

```kotlin
open class OpenClass: Parent { // 상속 가능
    fun finalMethod() {} // final, 오버라이드 불가능
    open fun openMethod() {} // 오버라이드 가능
    override fun aa() {} //오버라이드 가능
}
```

 > abstract
 ```kotlin
abstract class AbstClass {
    abstract fun abstFun()
    open fun aa() {} // override 허용
    fun bb() {} // 기본적으로 final
}
 ```

 ## public, internal, protected, private
  
   * public(기본) - 어디서든 볼 수 있다
   * internal - 같은 모듈에서 볼 수 있다.
   * protected - 하위 클래스에서 볼 수 있다.
   * private - 같은 파일만 볼 수 있다

## 내부 클래스, 중첩 클래스
    
 * 코틀린 중첩클래스는 자바 static 중첩 클래스와 같다
 * 바깥 클래스의 참조를 포함 하려면 inner 를 붙여야 한다.

 ```kotlin

 class Outer {
     class Inner { //Outer 참조 안함. 자바에서 static class
         
     }
 }

 class Outer {
     inner class Inner { //Outer 참조. 자바에서 class
         fun getOuter : Outer = this@Outer
     }
 }
 ``` 

 ## 봉인 클래스

 * sealed 정의한 상위클래스 를 상속한 하위 클래스의 정의를 제한한다
 * sealed 하위클래스는 중첩클래스로 정의해야한다.
 * when에서 sealed 클래스를 처리 하면 디폴트가 필요 없다. 하위 클래스가 추가되면 when문에서 컴파일 에러가 발생한다.

```kotlin
sealed class Expr {
    class Num(val value: Int) : Expr()
    class Sum(Val left: Expr, val right: Expr) : Expr()
}

fun eval(e: Expr) : Int = 
    when(e) {
        is Expr.Num -> e.value
        is Expr.sum -> eval(e.right) + eval(e.left)
    }
```

